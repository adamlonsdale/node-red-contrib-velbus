<script type="text/x-red" data-template-name="velbus-switch">


	<div class="form-row">
        <label for="node-input-connector"><i class="fa fa-tag"></i> Velbus</label>
        <input id="node-input-connector" type="text" style="width:70%">
    </div>

	<div class="form-row">
        <label for="node-input-outputs"><i class="fa fa-hand-pointer"></i> Outputs</label>
        <select id="node-input-outputs" style="width: 70%">
            <option value="1" selected="selected">Listen to short taps only</option>
            <option value="2">Listen to short and long tabs</option>
            <option value="3">Listen to short tabs, long tabs, and other inputs</option>
		</select>
    </div>

	<div class="form-row">
        <label for="node-input-address"><i class="fa fa-envelope"></i> Address</label>
        <select id="node-input-address" style="width: 70%"></select>
    </div>

     <div class="form-row">
        <label for="node-input-channel"><i class="fa fa-dot-circle-o"></i> Channel</label>
        <select id="node-input-channel" style="width: 70%">
	        <option value="1">Button 1</option>
	        <option value="2">Button 2</option>
	        <option value="3">Button 3</option>
	        <option value="4">Button 4</option>
	        <option value="5">Button 5</option>
	        <option value="6">Button 6</option>
	        <option value="7">Button 7</option>
	        <option value="8">Button 8</option>
	        <option value="9">Button 9</option>
	        <option value="10">Button 10</option>
	        <option value="11">Button 11</option>
	        <option value="12">Button 12</option>
	        <option value="13">Button 13</option>
	        <option value="14">Button 14</option>
	        <option value="15">Button 15</option>
	        <option value="16">Button 16</option>
	        <option value="17">Button 17</option>
	        <option value="18">Button 18</option>
	        <option value="19">Button 19</option>
	        <option value="20">Button 20</option>
	        <option value="21">Button 21</option>
	        <option value="22">Button 22</option>
	        <option value="23">Button 23</option>
	        <option value="24">Button 24</option>
	        <option value="25">Button 25</option>
	        <option value="26">Button 26</option>
	        <option value="27">Button 27</option>
	        <option value="28">Button 28</option>
	        <option value="29">Button 29</option>
	        <option value="30">Button 30</option>
	        <option value="31">Button 31</option>
	        <option value="32">Button 32</option>
        </select>
    </div>

	<div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <div style="display: inline-block; position: relative; width: 70%; height: 20px;">
            <a id="node-input-get-label" class="editor-button"
                style="position: absolute; left: 0px; top: 0px;">
                <i class="fa fa-search"></i>
            </a>
            <div style="position: absolute; left: 40px; right: 0px;">
                <input id="node-input-name" class="node-input-name-switch" type="text" style="width:100%">
            </div>
        </div>
    </div>


	<div class="form-row on-status" style="display:none; color: darkorange">
        <span><i class="fa fa-info-circle"></i></span>
        <span class="on-status-text">Status text here</span>
    </div>

</script>

<script type="text/javascript">

	RED.nodes.registerType('velbus-switch', {
		category: 'Velbus',
		color: '#e1444e',
		defaults: {
			outputs: {value:1},
			connector: {value: "", type: "velbus-connector"},
			address: {value: "", required: true},
			channel: {value: "", required: true},
			name: {value: "", required: false}
		},
		inputs: 1,
		outputs: 3,
		outputLabels: ["Short pressed", "Long pressed", "Details"],
		align: 'right',
		icon: "velbus.png",
		paletteLabel: "Button",
		findNamesIid: -1,

		label() {
			if (this.address && this.channel) {
				return this.name || `Button @ ${parseInt(this.address).toString(16).toUpperCase()}, ch ${this.channel}`;
			} else {
				return this.name || 'Button'
			}

		},


		oneditsave() {
			clearInterval(this.findNamesIid);
			console.info("oneditsave switch @", this.address, "ch", this.channel);
			//$.get('velbus/init-velbus-port');
		},

		oneditprepare() {

			$.get("velbus/get-modules").then(modules => {

				if (modules.length > 0) {
					setModules(JSON.parse(modules), this.address);
				}
			});

			// $("#node-input-connector").change((that) => {
			//
			// });

			$("#node-input-address").change((that) => {
				//console.log("chnge address", $("#node-input-address option:selected").data().nrOfChannels);


				setTimeout(() => {
					const address = parseInt($('#node-input-address').val());
					const $selectedOption = $(that.target.selectedOptions);
					let nrOfChannels = 0;
					if ($selectedOption && $selectedOption.length > 0) {
						nrOfChannels = parseInt($selectedOption.data().nrOfChannels);
					}

					// if (address) {
					// 	for (let channel = 1; channel < nrOfChannels; channel++) {
					// 		setTimeout(() => {
					// 			getChannelName(address, channel)
					// 		}, 1000);
					// 	}
					// }


					if (nrOfChannels > 0) {
						$("#node-input-channel option").each((index, el) => {
							//console.log( index + ": " + $( that ).text() );
							if (index >= nrOfChannels) {
								$(el).attr("disabled", "disabled");
							} else {
								$(el).removeAttr("disabled");
							}
						});

						$.get(`velbus/request-channel-names/${address}/${nrOfChannels}`);

						//poll until all names are found
						let pollCount = 0;
						clearInterval(this.findNamesIid);
						this.findNamesIid = setInterval(() => {
							$.get(`velbus/get-channel-names/${address}`).then(channelNames => {
								channelNames = JSON.parse(channelNames);
								setChannelNames(channelNames);
								pollCount++;
								if (pollCount > 15 || nrOfChannels + 1 === channelNames.length) { // + 1 because of first being empty
									clearInterval(this.findNamesIid);
								}
							});

						}, 1500);
					}

				}, 400);

			});


			// $("#node-input-scan").click(() => {
			// 	searchAndSelectModule();
			// 	// if ($('#node-input-address').prop("tagName") === "INPUT") {
			// 	// 	searchAndSelectModule();
			// 	// } else {
			// 	// 	manualSwitchModule();
			// 	// }
			//
			// });


			$("#node-input-get-label").click(() => {
				const address = parseInt($('#node-input-address').val());
				const channel = parseInt($('#node-input-channel').val());
				if (address && channel) {
					const optionText = $(`#node-input-channel option[value="${channel}"]`).text();
					$('#node-input-name').val(optionText);
					// const url = `velbus/get-name-for-button/${address}/${channel}`;
					// //console.log("url", url);
					// $.get(url).then(msg => {
					// 	if (msg === "no velbus") {
					// 		RED.notify("Deploy first to connect to Velbus ...", "error");
					// 	} else {
					// 		$('#node-input-name').val(msg);
					// 	}
					// });
				} else {
					RED.notify("Add an Address and Channel first.", "error");
				}
			});
		},

		oneditcancel() {
			clearInterval(this.findNamesIid);
		},

		oneditdelete() {
			clearInterval(this.findNamesIid);
		}

	});

	// RED.comms.subscribe("onError", (text) => {
	// 	console.log("onError", text);
	// 	$(".on-status-text").text(text);
	// 	$(".on-status").show();
	// 	RED.notify(text, "error");
	// });
	//
	// RED.comms.subscribe("onLog", (key, text) => {
	// 	console.log("onLog", key, text);
	// 	$(".on-status-text").text(text);
	// 	$(".on-status").show();
	// 	RED.notify(text, "info");
	// });

	// RED.comms.subscribe("onVelbusModuleFound", (topic, modules) => {
	// 	console.log("subscribe onVelbusModuleFound", modules);
	// 	setModules(modules, this.address);
	// });


	function setModules(modules, prevAddress) {

		// RESET OPTIONS
		$('#node-input-address').empty();

		// SET MODULES AS OPTIONS
		modules.forEach(function (module) {
			if (module.hasInput && module.nrOfChannels > 0) {
				$('#node-input-address').append(`
					<option
						value="${module.address}"
						data-nr-of-channels="${module.nrOfChannels}"
					>
						${module.name} @ ${module.address.toString(16).toUpperCase()}
					</option>`);
			}
		});

		// RESET CURRENT VALUE
		$('#node-input-address').val(prevAddress);
	}

	function setChannelNames(channelNames) {
		console.log("channelNames", channelNames);
		channelNames.forEach(channel => {
			console.log(channel);
			if (channel) {
				$(`#node-input-channel option[value="${channel.id}"]`).text(`${channel.id}. ${channel.name}`);
			}
		});

	}


	// RED.comms.subscribe("onVelbusButtonName ", (topic, data) => {
	// 	console.log("onVelbusButtonName topic, data", topic, data);
	// 	if (this.address === data.address && this.channel === data.channel) {
	// 		$('#node-input-name').val(data.label)
	// 	}
	// });


</script>


<script type="text/x-red" data-help-name="velbus-switch">
    <p>Velbus Switch node to send and listen to button events.</p>

    <h3>Setup</h3>
    <p>The velbus serial port is found automatically. You might restart the Node-red service on first deploy.</p>
    <p>Address: Decimal value! If your module is not found by the search feature, you can fill it in manually</p>

    <h3>Listening for button events</h3>
    <p>The event message that the Button sends contains the following data in the <b>msg.payload</b>:</p>
    <dl class="message-properties">
        <dt>pressed<span class="property-type">string</span></dt>
        <dd>When the button is pressed.</dd>

        <dt>released<span class="property-type">string</span></dt>
        <dd>When the button is released.</dd>

        <dt>longPressed<span class="property-type">string</span></dt>
        <dd>When the button is pressed more then 2 seconds.</dd>
    </dl>

    <h3>Sending button events</h3>
	<p>You can mimic button events by injecting a message like so:
	<dl class="message-properties">
        <dt>msg.payload="press"<span class="property-type"></span></dt>
        <dd>This mimics a short press (press and release). Recommended and easiest for most scenarios.</dd>

		<dt>msg.payload="pressed"<span class="property-type"></span></dt>
        <dd>This mimics <b>only</b> a press.<br>
            You are supposed to send a <pre>released</pre> command afterwards.
            If you want to mimic a long press (> 2s), see below.</dd>

        <dt>msg.payload="released"<span class="property-type"></span></dt>
        <dd>This mimics an release. Required after a <pre>(long)pressed</pre></dd>

        <dt>msg.payload="longPressed"<span class="property-type"></span></dt>
        <dd>Mimics a long press. This will only work if you first mimic a <pre>pressed</pre> then a <pre>longPressed</pre>,
        and finally a <pre>released</pre></dd>
    </dl>





</script>